reRPC
=====

reRPC is a small RPC framework built on [protocol buffers][protobuf] and the Go
standard library's `net/http`. It generates code from API definition files so
you can focus on your application logic: no more artisanal query parameter
parsing, no more debates between PUT and PATCH, and no more hand-written
clients.

reRPC servers and clients use the [gRPC][grpc] wire protocol. reRPC servers
work seamlessly with clients generated by [any gRPC
implementation][grpc-implementations], command-line tools like [grpcurl][], and
proxies like [gRPC-Gateway][grpc-gateway] and [Envoy][envoy]. Similarly, reRPC
clients can call any gRPC server.

reRPC servers also support the [Twirp][twirp] protocol. Of course, clients
generated by [any Twirp implementation][twirp-implementations] work with reRPC
servers. More importantly, Twirp's JSON variant is perfect for debugging with
cURL.

Sadly, nothing's free. To keep the implementation simple and expose the same
features over multiple protocols, reRPC only supports unary (request-response)
RPCs. There's an [open issue][streaming-issue] for discussion of streaming
support.

## A Small Example

Curious what all this looks like in practice? Here's the smallest possible
server. You can find more realistic examples in the [API documentation][godoc].

```go
package main

import (
  "context"
  "net/http"

  "github.com/akshayjshah/rerpc"
  pingpb "github.com/akshayjshah/rerpc/internal/pingpb/v0" // generated
)

type PingServer struct {
  pingpb.UnimplementedPingServerReRPC // returns errors from all methods
}

func main() {
  ping := &PingServer{}
  mux := http.NewServeMux()
  mux.Handle(pingpb.NewPingHandlerReRPC(ping))
  http.ListenAndServeTLS(":https", "cert.pem", "key.pem", mux)
}
```

## Status

This is the earliest of early alphas: APIs *will* break before the first stable
release.

## Support and Versioning

reRPC supports:

* The [two most recent major releases][go-support-policy] of Go.
* Version 3 of the protocol buffer language ([proto3][]).
* [APIv2][] of protocol buffers in Go (`google.golang.org/protobuf`).

Within those parameters, reRPC follows semantic versioning.

That said, please remember that reRPC is one person's labor of love. It'll
probably take me a few days to respond to issues and pull requests. If you're
using reRPC in production, I'd love your [help maintaining this
project][maintainers-issue].

## Legal

Offered under the [MIT license][license]. This is a personal project, developed
in my spare time - it's not endorsed by, supported by, or (as far as I know)
used by my employer.

[protobuf]: https://developers.google.com/protocol-buffers
[grpc]: https://grpc.io/
[grpc-implementations]: https://grpc.io/docs/languages/
[grpcurl]: https://github.com/fullstorydev/grpcurl
[grpc-gateway]: https://grpc-ecosystem.github.io/grpc-gateway/
[envoy]: https://www.envoyproxy.io/
[twirp]: https://twitchtv.github.io/twirp/
[twirp-implementations]: https://github.com/twitchtv/twirp#implementations-in-other-languages
[streaming-issue]: https://github.com/akshayjshah/rerpc/issues/1
[maintainers-issue]: https://github.com/akshayjshah/rerpc/issues/2
[go-support-policy]: https://golang.org/doc/devel/release#policy
[license]: https://github.com/akshayjshah/rerpc/blob/main/LICENSE.txt
[godoc]: https://pkg.go.dev/github.com/akshayjshah/rerpc
[proto3]: https://cloud.google.com/apis/design/proto3
[APIv2]: https://blog.golang.org/protobuf-apiv2
