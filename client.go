package rerpc

import (
	"bytes"
	"context"
	"errors"
	"io"
	"io/ioutil"
	"math"
	"net/http"
	"strconv"
	"time"

	"google.golang.org/protobuf/proto"

	"github.com/akshayjshah/rerpc/internal/statuspb/v0"
)

// Doer is the transport-level interface reRPC expects HTTP clients to
// implement. The standard library's http.Client implements Doer.
type Doer interface {
	Do(*http.Request) (*http.Response, error)
}

type invokeCfg struct {
	MinTimeout        time.Duration
	MaxTimeout        time.Duration
	EnableGzipRequest bool
	MaxResponseBytes  int
}

// A CallOption configures a reRPC client or a single call.
type CallOption interface {
	apply(*invokeCfg)
}

type callOptionFunc func(*invokeCfg)

func (f callOptionFunc) apply(cfg *invokeCfg) { f(cfg) }

// CallMinTimeout sets the minimum allowable timeout. Attempting a call with
// less than the minimum timeout immediately fails with CodeDeadlineExceeded.
//
// By default, any positive timeout is allowed.
func CallMinTimeout(d time.Duration) CallOption {
	return callOptionFunc(func(cfg *invokeCfg) {
		cfg.MinTimeout = d
	})
}

// CallMaxTimeout sets the maximum allowable timeout. Timeouts greater than the
// configured max (including calls with no timeout) are reduced to the maximum
// allowed. Setting the max timeout to zero allows any timeout.
//
// By default, there's no enforced max timeout.
func CallMaxTimeout(d time.Duration) CallOption {
	return callOptionFunc(func(cfg *invokeCfg) {
		cfg.MaxTimeout = d
	})
}

// GzipRequests enables or disables gzip compression of the request message.
// The client always requests gzipped responses, but most gRPC servers only
// support symmetrical compression.
//
// Since some gRPC servers don't support compression, requests are uncompressed
// by default.
func GzipRequests(enable bool) CallOption {
	// NB, the default is required by
	// https://github.com/grpc/grpc/blob/master/doc/compression.md - see test
	// case 6.
	return callOptionFunc(func(cfg *invokeCfg) {
		cfg.EnableGzipRequest = enable
	})
}

// CallMaxResponseBytes sets the maximum allowable response size (after
// compression, if applicable). Responses larger than the configured size fail
// early, and the data is never read into memory. Setting the maximum to zero
// allows any response size.
//
// By default, the client allows any response size.
func CallMaxResponseBytes(n int) CallOption {
	return callOptionFunc(func(cfg *invokeCfg) {
		cfg.MaxResponseBytes = n
	})
}

// Invoke is the client-side implementation of a single RPC defined by a
// protocol buffer service. It's the interface between the reRPC library and
// the code generated by the reRPC protoc plugin; most users won't ever need to
// deal with it directly.
//
// To see an example of how Invoke is used in the generated code, see the
// internal/pingpb/v0 package.
func Invoke(ctx context.Context, url string, doer Doer, req, res proto.Message, opts ...CallOption) error {
	// directly returning invoke's output puts a typed nil into the error
	// interface, so the error is mysteriously non-nil.
	if err := invoke(ctx, url, doer, req, res, opts); err != nil {
		return err
	}
	return nil
}

func invoke(ctx context.Context, url string, doer Doer, req, res proto.Message, opts []CallOption) *Error {
	cfg := &invokeCfg{}
	for _, opt := range opts {
		opt.apply(cfg)
	}

	deadline, hasDeadline := ctx.Deadline()
	var encodedTimeout string
	untilDeadline := time.Duration(math.MaxInt64)
	if hasDeadline {
		untilDeadline = time.Until(deadline)
	}
	if max := cfg.MaxTimeout; max > 0 && untilDeadline > max {
		var cancel context.CancelFunc
		ctx, cancel = context.WithTimeout(ctx, max)
		defer cancel()
		hasDeadline = true
		untilDeadline = max
	}
	if untilDeadline < 0 {
		return errorf(CodeDeadlineExceeded, "no time to make RPC: timeout is %v", untilDeadline)
	}
	if untilDeadline < cfg.MinTimeout {
		return errorf(CodeDeadlineExceeded, "no time to make RPC: timeout is %v, configured min is %v", untilDeadline, cfg.MinTimeout)
	}
	if hasDeadline {
		if timeout, err := encodeTimeout(untilDeadline); err == nil {
			// Tests verify that the error in encodeTimeout is unreachable, so we
			// should be safe without observability for the error case.
			encodedTimeout = timeout
		}
	}

	requestCompression := CompressionGzip
	if !cfg.EnableGzipRequest {
		requestCompression = CompressionIdentity
	}

	body := &bytes.Buffer{}
	if err := marshalLPM(body, req, requestCompression, 0 /* maxBytes */); err != nil {
		return errorf(CodeInvalidArgument, "can't marshal request as protobuf: %w", err)
	}

	request, err := http.NewRequestWithContext(ctx, http.MethodPost, url, body)
	if err != nil {
		return errorf(CodeInternal, "can't create HTTP request: %w", err)
	}
	request.Header.Set("User-Agent", UserAgent)
	request.Header.Set("Content-Type", TypeDefaultGRPC)
	request.Header.Set("Grpc-Encoding", requestCompression)
	request.Header.Set("Grpc-Accept-Encoding", acceptEncodingValue) // always advertise identity & gzip
	if encodedTimeout != "" {
		request.Header.Set("Grpc-Timeout", encodedTimeout)
	}
	request.Header.Set("Te", "trailers")

	response, err := doer.Do(request)
	if err != nil {
		if errors.Is(err, context.Canceled) {
			return errorf(CodeCanceled, "context canceled")
		}
		if errors.Is(err, context.DeadlineExceeded) {
			return errorf(CodeDeadlineExceeded, "context deadline exceeded")
		}
		// TODO: observability
		return wrap(CodeUnknown, errors.New("error making request (no usable response or status code)"))
	}
	defer response.Body.Close()
	defer io.Copy(ioutil.Discard, response.Body)

	if response.StatusCode != http.StatusOK {
		code := CodeUnknown
		if c, ok := httpToGRPC[response.StatusCode]; ok {
			code = c
		}
		return errorf(code, "HTTP status %v", response.StatusCode)
	}
	compression := response.Header.Get("Grpc-Encoding")
	if compression == "" {
		compression = CompressionIdentity
	}
	switch compression {
	case CompressionIdentity, CompressionGzip:
	default:
		// Per https://github.com/grpc/grpc/blob/master/doc/compression.md, we
		// should return CodeInternal and specify acceptable compression(s) (in
		// addition to setting the Grpc-Accept-Encoding header).
		return errorf(CodeInternal, "unknown compression %q: accepted grpc-encoding values are %v", compression, acceptEncodingValue)
	}

	// When there's no body, errors sent from the first-party gRPC servers will
	// be in the headers.
	if err := extractError(response.Header); err != nil {
		return err
	}

	// Handling this error is a little complicated - read on.
	unmarshalErr := unmarshalLPM(response.Body, res, compression, cfg.MaxResponseBytes)
	// To ensure that we've read the trailers, read the body to completion.
	io.Copy(io.Discard, response.Body)
	serverErr := extractError(response.Trailer)
	if serverErr != nil {
		// Server sent us an error. In this case, we don't care if unmarshalErr is
		// non-nil.
		return serverErr
	} else if unmarshalErr != nil {
		// Server thinks response was successful, so unmarshalErr is real.
		return errorf(CodeUnknown, "server returned invalid protobuf: %w", unmarshalErr)
	}
	// Server thinks response was successful and so do we, so we're done.
	return nil
}

func extractError(h http.Header) *Error {
	codeHeader := h.Get("Grpc-Status")
	codeIsSuccess := (codeHeader == "" || codeHeader == "0")
	if codeIsSuccess {
		return nil
	}

	code, err := strconv.Atoi(codeHeader)
	if err != nil {
		return errorf(CodeUnknown, "gRPC protocol error: got invalid error code %q", codeHeader)
	}
	message := percentDecode(h.Get("Grpc-Message"))
	ret := wrap(Code(code), errors.New(message))

	detailsBinaryEncoded := h.Get("Grpc-Status-Details-Bin")
	if len(detailsBinaryEncoded) > 0 {
		detailsBinary, err := decodeBinaryHeader(detailsBinaryEncoded)
		if err != nil {
			// TODO: observability
			return errorf(CodeUnknown, "server returned invalid grpc-error-details-bin trailer")
		}
		var status statuspb.Status
		if err := proto.Unmarshal(detailsBinary, &status); err != nil {
			// TODO: observability
			return errorf(CodeUnknown, "server returned invalid protobuf for error details")
		}
		ret.details = status.Details
		// Prefer the protobuf-encoded data to the headers (grpc-go does this too).
		ret.code = Code(status.Code)
		ret.err = errors.New(status.Message)
	}

	return ret
}
