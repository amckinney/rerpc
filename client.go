package rerpc

import (
	"bytes"
	"context"
	"errors"
	"io"
	"io/ioutil"
	"net/http"
	"strconv"
	"time"

	"google.golang.org/protobuf/proto"

	"github.com/akshayjshah/rerpc/internal/statuspb/v0"
)

// Doer is the transport-level interface reRPC expects HTTP clients to
// implement. The standard library's http.Client implements Doer.
type Doer interface {
	Do(*http.Request) (*http.Response, error)
}

// TODO: placeholder, used in generated code
type CallOption struct{}

// Invoke is the client-side implementation of a single RPC defined by a
// protocol buffer service. It's the interface between the reRPC library and
// the code generated by the reRPC protoc plugin; most users won't ever need to
// deal with it directly.
//
// To see an example of how Invoke is used in the generated code, see the
// internal/pingpb/v0 package.
func Invoke(ctx context.Context, url string, doer Doer, req, res proto.Message) error {
	// directly returning invoke's output puts a typed nil into the error
	// interface, so the error is mysteriously non-nil.
	if err := invoke(ctx, url, doer, req, res); err != nil {
		return err
	}
	return nil
}

func invoke(ctx context.Context, url string, doer Doer, req, res proto.Message) *Error {
	body := &bytes.Buffer{}
	if err := marshalLPM(body, req, CompressionIdentity, 0 /* maxBytes */); err != nil {
		return errorf(CodeInvalidArgument, "can't marshal request as protobuf: %w", err)
	}

	request, err := http.NewRequestWithContext(ctx, http.MethodPost, url, body)
	if err != nil {
		return errorf(CodeInternal, "can't create HTTP request: %w", err)
	}
	request.Header.Set("Content-Type", TypeDefaultGRPC)
	request.Header.Set("Te", "trailers")

	if deadline, ok := ctx.Deadline(); ok {
		untilDeadline := time.Until(deadline)
		if untilDeadline <= 0 {
			return errorf(CodeDeadlineExceeded, "no time to make RPC: timeout is %v", untilDeadline)
		}
		if timeout, err := encodeTimeout(untilDeadline); err == nil {
			// Tests verify that the error in encodeTimeout is unreachable, so we
			// should be safe without observability for the error case.
			request.Header.Set("Grpc-Timeout", timeout)
		}
	}

	response, err := doer.Do(request)
	if err != nil {
		if errors.Is(err, context.Canceled) {
			return errorf(CodeCanceled, "context canceled")
		}
		if errors.Is(err, context.DeadlineExceeded) {
			return errorf(CodeDeadlineExceeded, "context deadline exceeded")
		}
		// TODO: observability
		return wrap(CodeUnknown, errors.New("error making request (no usable response or status code)"))
	}
	defer response.Body.Close()
	defer io.Copy(ioutil.Discard, response.Body)

	if response.StatusCode != http.StatusOK {
		code := CodeUnknown
		if c, ok := httpToGRPC[response.StatusCode]; ok {
			code = c
		}
		return errorf(code, "HTTP status %v", response.StatusCode)
	}
	compression := response.Header.Get("Grpc-Encoding")
	if compression == "" {
		compression = CompressionIdentity
	}

	// When there's no body, errors sent from the first-party gRPC servers will
	// be in the headers.
	if err := extractError(response.Header); err != nil {
		return err
	}

	// Handling this error is a little complicated - read on.
	unmarshalErr := unmarshalLPM(response.Body, res, compression, 0 /* maxSize */)
	// To ensure that we've read the trailers, read the body to completion.
	io.Copy(io.Discard, response.Body)
	serverErr := extractError(response.Trailer)
	if serverErr != nil {
		// Server sent us an error. In this case, we don't care if unmarshalErr is
		// non-nil.
		return serverErr
	} else if unmarshalErr != nil {
		// Server thinks response was successful, so unmarshalErr is real.
		return errorf(CodeUnknown, "server returned invalid protobuf: %w", unmarshalErr)
	}
	// Server thinks response was successful and so do we, so we're done.
	return nil
}

func extractError(h http.Header) *Error {
	codeHeader := h.Get("Grpc-Status")
	codeIsSuccess := (codeHeader == "" || codeHeader == "0")
	if codeIsSuccess {
		return nil
	}

	code, err := strconv.Atoi(codeHeader)
	if err != nil {
		return errorf(CodeUnknown, "gRPC protocol error: got invalid error code %q", codeHeader)
	}
	message := percentDecode(h.Get("Grpc-Message"))
	ret := wrap(Code(code), errors.New(message))

	detailsBinaryEncoded := h.Get("Grpc-Status-Details-Bin")
	if len(detailsBinaryEncoded) > 0 {
		detailsBinary, err := decodeBinaryHeader(detailsBinaryEncoded)
		if err != nil {
			// TODO: observability
			return errorf(CodeUnknown, "server returned invalid grpc-error-details-bin trailer")
		}
		var status statuspb.Status
		if err := proto.Unmarshal(detailsBinary, &status); err != nil {
			// TODO: observability
			return errorf(CodeUnknown, "server returned invalid protobuf for error details")
		}
		ret.details = status.Details
		// Prefer the protobuf-encoded data to the headers (grpc-go does this too).
		ret.code = Code(status.Code)
		ret.err = errors.New(status.Message)
	}

	return ret
}
