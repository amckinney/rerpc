package rerpc

import (
	"context"
	"fmt"
	"net/http"
	"net/url"
)

// Doer is the transport-level interface reRPC expects HTTP clients to
// implement. The standard library's http.Client implements Doer.
type Doer interface {
	Do(*http.Request) (*http.Response, error)
}

type callCfg struct {
	Package           string
	Service           string
	Method            string
	EnableGzipRequest bool
	MaxResponseBytes  int64
	Interceptor       Interceptor
	Hooks             *Hooks
}

// A CallOption configures a reRPC client or a single call.
//
// In addition to any options grouped in the documentation below, remember that
// Hooks and Options are also valid CallOptions.
type CallOption interface {
	applyToCall(*callCfg)
}

// A Client calls a single method defined by a protocol buffer service. It's
// the interface between the reRPC library and the client code generated by the
// reRPC protoc plugin; most users won't ever need to deal with it directly.
//
// To see an example of how Client is used in the generated code, see the
// internal/ping/v1test package.
type Client struct {
	doer                 Doer
	baseURL              string
	pkg, service, method string
	opts                 []CallOption
}

// NewClient creates a Client. The supplied URL must be the root URL of the
// server's API, without a trailing slash (e.g., https://api.acme.com or
// https://acme.com/grpc). The supplied package, service, and method must be
// protobuf identifiers. Any options passed here apply to all calls made with
// this client.
//
// For example, to call the URL
// https://api.acme.com/acme.foo.v1.FooService/Bar, you'd pass the URL
// "https://api.acme.com", the package "acme.foo.v1", the service "FooService",
// and the method "Bar".
//
// Remember that NewClient is usually called from generated code - most users
// won't need to deal with it directly.
//
// TODO: refactor this into a one-shot call. There's virtually no work that
// happens at the client level outside generated code.
func NewClient(doer Doer, baseURL, pkg, service, method string, opts ...CallOption) *Client {
	return &Client{
		doer:    doer,
		baseURL: baseURL,
		pkg:     pkg,
		service: service,
		method:  method,
		opts:    opts,
	}
}

// Call creates a stream for the remote procedure. Any options passed apply
// only to the current call.
func (c *Client) Call(ctx context.Context, opts ...CallOption) Stream {
	md, ok := CallMeta(ctx)
	if !ok {
		ctx = c.Context(ctx)
		md, _ = CallMeta(ctx)
	}
	spec := md.Spec
	methodURL := fmt.Sprintf("%s/%s.%s/%s", c.baseURL, spec.Package, spec.Service, spec.Method)
	next := CallStreamFunc(func(ctx context.Context) Stream {
		return newClientStream(ctx, c.doer, methodURL, spec.ReadMaxBytes, spec.RequestCompression == CompressionGzip)
	})
	// TODO: apply interceptors
	return next(ctx)
}

func (c *Client) Context(ctx context.Context, opts ...CallOption) context.Context {
	cfg := callCfg{
		Package: c.pkg,
		Service: c.service,
		Method:  c.method,
	}
	for _, opt := range c.opts {
		opt.applyToCall(&cfg)
	}
	for _, opt := range opts {
		opt.applyToCall(&cfg)
	}

	spec := &Specification{
		Package:            cfg.Package,
		Service:            cfg.Service,
		Method:             cfg.Method,
		RequestCompression: CompressionGzip,
		ReadMaxBytes:       cfg.MaxResponseBytes,
	}
	methodURL := fmt.Sprintf("%s/%s.%s/%s", c.baseURL, spec.Package, spec.Service, spec.Method)
	if url, err := url.Parse(methodURL); err == nil {
		spec.Path = url.Path
	}
	if !cfg.EnableGzipRequest {
		spec.RequestCompression = CompressionIdentity
	}
	reqHeader := make(http.Header, 5)
	reqHeader.Set("User-Agent", UserAgent())
	reqHeader.Set("Content-Type", TypeDefaultGRPC)
	reqHeader.Set("Grpc-Encoding", spec.RequestCompression)
	reqHeader.Set("Grpc-Accept-Encoding", acceptEncodingValue) // always advertise identity & gzip
	reqHeader.Set("Te", "trailers")
	return NewCallContext(ctx, *spec, reqHeader, make(http.Header))
}
