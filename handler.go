package rerpc

import (
	"context"
	"errors"
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"strconv"
	"strings"

	"github.com/akshayjshah/rerpc/internal/google.golang.org/genproto/googleapis/rpc/status"
	"github.com/golang/protobuf/jsonpb"
	"github.com/golang/protobuf/proto"
)

var (
	errNoTimeout      = errors.New("no timeout")
	jsonpbMarshaler   = &jsonpb.Marshaler{}
	jsonpbUnmarshaler = &jsonpb.Unmarshaler{AllowUnknownFields: true}
)

// A Handler is a single RPC defined by a protocol buffer service. It's the
// interface between the reRPC library and the code generated by the reRPC
// protoc plugin; most users won't ever need to deal with it directly.
//
// To see an example of how Handler is used in the generated code, see the
// internal/pingpb package.
type Handler struct {
	Implementation func(context.Context, proto.Message) (proto.Message, error)
}

// Serve executes the handler, much like the standard library's http.Handler.
// Unlike http.Handler, it requires a pointer to the protoc-generated request
// struct. See the internal/pingpb package for an example of how this code is
// used in reRPC's generated code.
//
// As long as the caller allocates a new request struct for each call, this
// method is safe to use concurrently.
func (h *Handler) Serve(w http.ResponseWriter, r *http.Request, msg proto.Message) {
	// To ensure that we can re-use connections, always consume and close the
	// request body.
	//
	// TODO: look into documentation, is this necessary?
	defer r.Body.Close()
	defer io.Copy(ioutil.Discard, r.Body)

	if r.Method != http.MethodPost {
		// grpc-go returns a 500 here, but interoperability with non-gRPC HTTP
		// clients is much better if we return a 405.
		w.Header().Set("Allow", http.MethodPost)
		w.WriteHeader(http.StatusMethodNotAllowed)
		return
	}

	ctype := r.Header.Get("Content-Type")
	if ctype != TypeDefaultGRPC && ctype != TypeProtoGRPC && ctype != TypeJSON {
		// grpc-go returns 500, but the spec recommends 415.
		// https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-HTTP2.md#requests
		w.WriteHeader(http.StatusUnsupportedMediaType)
		fmt.Fprintf(w, "unsupported content-type %q", ctype)
		return
	}

	// We're always going to respond with the same content type as the request.
	w.Header().Set("Content-Type", ctype)
	// We always send grpc-accept-encoding. Set it here so it's ready to go in
	// future error cases.
	w.Header().Set("Grpc-Accept-Encoding", acceptEncodingValue)
	if ctype != TypeJSON {
		// From here on, every gRPC response will have these trailers.
		w.Header().Add("Trailer", "Grpc-Status")
		w.Header().Add("Trailer", "Grpc-Status-Message")
		w.Header().Add("Trailer", "Grpc-Status-Details-Bin")
	}

	requestEncoding := EncodingIdentity
	if me := r.Header.Get("Grpc-Encoding"); me != "" {
		switch me {
		case EncodingIdentity:
			requestEncoding = EncodingIdentity
		case EncodingGzip:
			requestEncoding = EncodingGzip
		default:
			// Per https://github.com/grpc/grpc/blob/master/doc/compression.md, we
			// should return CodeUnimplemented.
			w.WriteHeader(http.StatusNotImplemented)
			writeError(w, ctype, Wrap(
				CodeUnimplemented,
				fmt.Errorf("the reRPC gRPC implementation doesn't support the %q encoding", me),
			))
			return
		}
	}

	// Follow https://github.com/grpc/grpc/blob/master/doc/compression.md.
	// (The grpc-go implementation doesn't read the "grpc-accept-encoding" header
	// and doesn't support compression method asymmetry.)
	responseEncoding := requestEncoding
	if mae := r.Header.Get("Grpc-Accept-Encoding"); mae != "" {
		for _, enc := range strings.FieldsFunc(mae, splitOnCommasAndSpaces) {
			switch enc {
			case EncodingIdentity:
				responseEncoding = EncodingIdentity
				break
			case EncodingGzip:
				responseEncoding = EncodingGzip
				break
			}
		}
	}
	w.Header().Set("Grpc-Encoding", responseEncoding)

	if to, err := parseTimeout(r.Header.Get("Grpc-Timeout")); err != nil && err != errNoTimeout {
		w.WriteHeader(http.StatusBadRequest)
		writeError(w, ctype, Wrap(CodeInvalidArgument, err))
		return
	} else if err != nil {
		ctx, cancel := context.WithTimeout(r.Context(), to)
		defer cancel()
		r = r.WithContext(ctx)
	}

	if err := unmarshal(r.Body, msg, ctype, requestEncoding); err != nil {
		if re, ok := AsError(err); ok {
			w.WriteHeader(re.Code().http())
		} else {
			w.WriteHeader(http.StatusInternalServerError)
		}
		writeError(w, ctype, err)
		return
	}

	res, err := h.Implementation(r.Context(), msg)
	if err != nil {
		writeError(w, ctype, err)
		return
	}

	if err := marshal(w, res, ctype, responseEncoding); err != nil {
		// TODO: observability for this class of errors, probably some injected func
		return
	}

	if ctype != TypeJSON {
		w.Header().Set("Grpc-Status", "0")
		w.Header().Set("Grpc-Status-Message", "")
		w.Header().Set("Grpc-Status-Details-Bin", "")
	}

	if f, ok := w.(http.Flusher); ok {
		f.Flush()
	}
}

func splitOnCommasAndSpaces(c rune) bool {
	return c == ',' || c == ' '
}

func writeError(w http.ResponseWriter, ctype string, err error) {
	s := &status.Status{}
	if re, ok := AsError(err); ok {
		s.Code = int32(re.Code())
		s.Details = re.Details()
		if e := re.Unwrap(); e != nil {
			s.Message = e.Error()
		} else {
			s.Message = e.Error()
		}
	}
	if ctype != TypeJSON {
		w.Header().Set("Grpc-Status", strconv.Itoa(int(s.Code)))
		w.Header().Set("Grpc-Status-Message", encodeGrpcMessage(s.Message))
		if bin, err := proto.Marshal(s); err != nil {
			w.Header().Set("Grpc-Status-Details-Bin", encodeBinaryHeader(bin))
		} else {
			// FIXME: do something with this error
		}
	}
	if err := jsonpbMarshaler.Marshal(w, s); err != nil {
		// FIXME: do something with this error
	}
}
