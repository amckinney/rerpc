package rerpc

import (
	"compress/gzip"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"strconv"
	"strings"

	"google.golang.org/protobuf/proto"

	statuspb "github.com/rerpc/rerpc/internal/status/v1"
	"github.com/rerpc/rerpc/internal/twirp"
)

var (
	// Always advertise that reRPC accepts gzip compression.
	acceptEncodingValue    = strings.Join([]string{CompressionGzip, CompressionIdentity}, ",")
	acceptPostValueDefault = strings.Join(
		[]string{TypeDefaultGRPC, TypeProtoGRPC, TypeJSON},
		",",
	)
	acceptPostValueWithoutJSON = strings.Join(
		[]string{TypeDefaultGRPC, TypeProtoGRPC},
		",",
	)
)

type handlerCfg struct {
	DisableGzipResponse bool
	DisableTwirp        bool
	MaxRequestBytes     int
	Registrar           *Registrar
	Interceptor         Interceptor
	Hooks               *Hooks
}

// A HandlerOption configures a Handler.
//
// In addition to any options grouped in the documentation below, remember that
// Registrars, Hooks, and Options are also valid HandlerOptions.
type HandlerOption interface {
	applyToHandler(*handlerCfg)
}

type serveTwirpOption struct {
	Disable bool
}

func (o *serveTwirpOption) applyToHandler(cfg *handlerCfg) {
	cfg.DisableTwirp = o.Disable
}

// ServeTwirp enables or disables support for Twirp's JSON and protobuf
// formats. Disable Twirp if you only want your handlers to speak the gRPC
// protocol.
//
// By default, handlers support Twirp.
func ServeTwirp(enable bool) HandlerOption {
	return &serveTwirpOption{!enable}
}

// A Handler is the server-side implementation of a single RPC defined by a
// protocol buffer service. It's the interface between the reRPC library and
// the code generated by the reRPC protoc plugin; most users won't ever need to
// deal with it directly.
//
// To see an example of how Handler is used in the generated code, see the
// internal/pingpb/v0 package.
type Handler struct {
	methodFQN      string
	serviceFQN     string
	packageFQN     string
	newRequest     func() proto.Message
	implementation Func
	// rawGRPC is used only for our hand-rolled reflection handler, which needs
	// bidi streaming
	rawGRPC func(
		context.Context,
		http.ResponseWriter,
		*http.Request,
		string, // request compression
		string, // response compression
		*Hooks,
	)
	config handlerCfg
}

// NewHandler constructs a Handler. The supplied method, service, and package
// must be fully-qualified protobuf identifiers, and the newRequest constructor
// must be safe to call concurrently.
//
// For example, a handler might have method "acme.foo.v1.FooService.Bar",
// service "acme.foo.v1.FooService", and package "acme.foo.v1". In that case,
// the newRequest constructor would be:
//   func() proto.Message {
//     return &foopb.BarRequest{}
//   }
//
// Remember that NewHandler is usually called from generated code - most users
// won't need to deal with protobuf identifiers directly.
func NewHandler(
	methodFQN, serviceFQN, packageFQN string,
	newRequest func() proto.Message,
	impl Func,
	opts ...HandlerOption,
) *Handler {
	var cfg handlerCfg
	for _, opt := range opts {
		opt.applyToHandler(&cfg)
	}
	if reg := cfg.Registrar; reg != nil {
		reg.register(serviceFQN)
	}
	return &Handler{
		methodFQN:      methodFQN,
		serviceFQN:     serviceFQN,
		packageFQN:     packageFQN,
		newRequest:     newRequest,
		implementation: impl,
		config:         cfg,
	}
}

// ServeHTTP implements http.Handler.
func (h *Handler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	// To ensure that we can re-use connections, always consume and close the
	// request body.
	defer r.Body.Close()
	defer io.Copy(ioutil.Discard, r.Body)

	if r.Method != http.MethodPost {
		// grpc-go returns a 500 here, but interoperability with non-gRPC HTTP
		// clients is better if we return a 405.
		w.Header().Set("Allow", http.MethodPost)
		w.WriteHeader(http.StatusMethodNotAllowed)
		return
	}

	spec := &Specification{
		Method:              h.methodFQN,
		Service:             h.serviceFQN,
		Package:             h.packageFQN,
		Path:                r.URL.Path,
		ContentType:         r.Header.Get("Content-Type"),
		RequestCompression:  CompressionIdentity,
		ResponseCompression: CompressionIdentity,
	}
	if (spec.ContentType == TypeJSON || spec.ContentType == TypeProtoTwirp) && h.config.DisableTwirp {
		w.Header().Set("Accept-Post", acceptPostValueWithoutJSON)
		w.WriteHeader(http.StatusUnsupportedMediaType)
		return
	}
	if ct := spec.ContentType; ct != TypeDefaultGRPC && ct != TypeProtoGRPC && ct != TypeProtoTwirp && ct != TypeJSON {
		// grpc-go returns 500, but the spec recommends 415.
		// https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-HTTP2.md#requests
		w.Header().Set("Accept-Post", acceptPostValueDefault)
		w.WriteHeader(http.StatusUnsupportedMediaType)
		return
	}

	// We need to parse metadata before entering the interceptor stack, but we'd
	// like any errors we encounter to be visible to interceptors for
	// observability. We'll collect any such errors here and use them to
	// short-circuit early later on.
	//
	// NB, future refactorings will need to take care to avoid typed nils here.
	var failed *Error

	timeout, err := parseTimeout(r.Header.Get("Grpc-Timeout"))
	if err != nil && err != errNoTimeout {
		// Errors here indicate that the client sent an invalid timeout header, so
		// the error text is safe to send back.
		failed = wrap(CodeInvalidArgument, err)
	} else if err == nil {
		ctx, cancel := context.WithTimeout(r.Context(), timeout)
		defer cancel()
		r = r.WithContext(ctx)
	} // else err == errNoTimeout, nothing to do

	if spec.ContentType == TypeJSON || spec.ContentType == TypeProtoTwirp {
		if r.Header.Get("Content-Encoding") == "gzip" {
			spec.RequestCompression = CompressionGzip
		}
		// TODO: Actually parse Accept-Encoding instead of this hackery.
		if !h.config.DisableGzipResponse && strings.Contains(r.Header.Get("Accept-Encoding"), "gzip") {
			spec.ResponseCompression = CompressionGzip
		}
	} else {
		spec.RequestCompression = CompressionIdentity
		if me := r.Header.Get("Grpc-Encoding"); me != "" {
			switch me {
			case CompressionIdentity:
				spec.RequestCompression = CompressionIdentity
			case CompressionGzip:
				spec.RequestCompression = CompressionGzip
			default:
				// Per https://github.com/grpc/grpc/blob/master/doc/compression.md, we
				// should return CodeUnimplemented and specify acceptable compression(s)
				// (in addition to setting the Grpc-Accept-Encoding header).
				if failed == nil {
					failed = errorf(
						CodeUnimplemented,
						"unknown compression %q: accepted grpc-encoding values are %v",
						me, acceptEncodingValue,
					)
				}
			}
		}
		// Follow https://github.com/grpc/grpc/blob/master/doc/compression.md.
		// (The grpc-go implementation doesn't read the "grpc-accept-encoding" header
		// and doesn't support compression method asymmetry.)
		spec.ResponseCompression = spec.RequestCompression
		if h.config.DisableGzipResponse {
			spec.ResponseCompression = CompressionIdentity
		} else if mae := r.Header.Get("Grpc-Accept-Encoding"); mae != "" {
			for _, enc := range strings.FieldsFunc(mae, splitOnCommasAndSpaces) {
				switch enc {
				case CompressionGzip:
					spec.ResponseCompression = CompressionGzip
					// prefer gzip, so no continue
				case CompressionIdentity:
					spec.ResponseCompression = CompressionIdentity
					continue
				default:
					continue
				}
				break
			}
		}
	}

	// We may write to the body in the implementation (e.g., reflection handler), so we should
	// set headers here.
	w.Header().Set("Content-Type", spec.ContentType)
	if spec.ContentType != TypeJSON && spec.ContentType != TypeProtoTwirp {
		w.Header().Set("Grpc-Accept-Encoding", acceptEncodingValue)
		w.Header().Set("Grpc-Encoding", spec.ResponseCompression)
		// Every gRPC response will have these trailers.
		w.Header().Add("Trailer", "Grpc-Status")
		w.Header().Add("Trailer", "Grpc-Message")
		w.Header().Add("Trailer", "Grpc-Status-Details-Bin")
	}

	ctx := NewHandlerContext(r.Context(), *spec, r.Header, w.Header())
	var implementation Func
	if failed != nil {
		implementation = Func(func(context.Context, proto.Message) (proto.Message, error) {
			return nil, failed
		})
	} else if spec.ContentType == TypeJSON || spec.ContentType == TypeProtoTwirp {
		implementation = h.implementationTwirp(w, r, spec)
	} else {
		implementation = h.implementationGRPC(w, r, spec)
	}
	res, err := h.wrap(implementation)(ctx, h.newRequest())
	h.writeResult(r.Context(), w, spec, res, err)
}

func (h *Handler) implementationTwirp(w http.ResponseWriter, r *http.Request, spec *Specification) Func {
	return Func(func(ctx context.Context, req proto.Message) (proto.Message, error) {
		var body io.Reader = r.Body
		if spec.RequestCompression == CompressionGzip {
			gr, err := gzip.NewReader(body)
			if err != nil {
				return nil, errorf(CodeInvalidArgument, "can't read gzipped body")
			}
			defer gr.Close()
			body = gr
		}
		if max := h.config.MaxRequestBytes; max > 0 {
			body = &io.LimitedReader{
				R: body,
				N: int64(max),
			}
		}
		if spec.ContentType == TypeJSON {
			if err := unmarshalJSON(body, req); err != nil {
				return nil, wrap(CodeInvalidArgument, newMalformedError("can't unmarshal JSON body"))
			}
		} else {
			if err := unmarshalTwirpProto(body, req); err != nil {
				return nil, wrap(CodeInvalidArgument, newMalformedError("can't unmarshal Twirp protobuf body"))
			}
		}
		return h.implementation(ctx, req)
	})
}

func (h *Handler) implementationGRPC(w http.ResponseWriter, r *http.Request, spec *Specification) Func {
	return Func(func(ctx context.Context, req proto.Message) (proto.Message, error) {
		if raw := h.rawGRPC; raw != nil {
			raw(ctx, w, r, spec.RequestCompression, spec.ResponseCompression, h.config.Hooks)
			return nil, nil
		}
		if err := unmarshalLPM(r.Body, req, spec.RequestCompression, h.config.MaxRequestBytes); err != nil {
			return nil, errorf(CodeInvalidArgument, "can't unmarshal protobuf body")
		}
		return h.implementation(ctx, req)
	})
}

func (h *Handler) writeResult(ctx context.Context, w http.ResponseWriter, spec *Specification, res proto.Message, err error) {
	if spec.ContentType == TypeJSON || spec.ContentType == TypeProtoTwirp {
		h.writeResultTwirp(ctx, w, spec, res, err)
		return
	}
	h.writeResultGRPC(ctx, w, spec, res, err)
}

func (h *Handler) writeResultTwirp(ctx context.Context, w http.ResponseWriter, spec *Specification, res proto.Message, err error) {
	// Even if the client requested gzip compression, check Content-Encoding to
	// make sure some other HTTP middleware hasn't already swapped out the
	// ResponseWriter.
	if spec.ResponseCompression == CompressionGzip && w.Header().Get("Content-Encoding") == "" {
		w.Header().Set("Content-Encoding", "gzip")
		gw := gzWriterPool.Get().(*gzip.Writer)
		gw.Reset(w)
		w = &gzipResponseWriter{ResponseWriter: w, gw: gw}
		defer func() {
			gw.Close()           // close if we haven't already
			gw.Reset(io.Discard) // don't keep references
			gzWriterPool.Put(gw)
		}()
	}
	if err != nil {
		// Twirp always writes errors as JSON.
		writeErrorJSON(ctx, w, err, h.config.Hooks)
		return
	}
	if spec.ContentType == TypeJSON {
		marshalJSON(ctx, w, res, h.config.Hooks)
	} else {
		marshalTwirpProto(ctx, w, res, h.config.Hooks)
	}
}

func (h *Handler) writeResultGRPC(ctx context.Context, w http.ResponseWriter, spec *Specification, res proto.Message, err error) {
	if err != nil {
		writeErrorGRPC(ctx, w, err, h.config.Hooks)
		return
	}
	if err := marshalLPM(ctx, w, res, spec.ResponseCompression, 0 /* maxBytes */, h.config.Hooks); err != nil {
		// It's safe to write gRPC errors even after we've started writing the
		// body.
		writeErrorGRPC(ctx, w, errorf(CodeUnknown, "can't marshal protobuf response"), h.config.Hooks)
		return
	}
	writeErrorGRPC(ctx, w, nil, h.config.Hooks)
}

func (h *Handler) wrap(next Func) Func {
	if h.config.Interceptor != nil {
		return h.config.Interceptor.Wrap(next)
	}
	return next
}

func splitOnCommasAndSpaces(c rune) bool {
	return c == ',' || c == ' '
}

func writeErrorJSON(ctx context.Context, w http.ResponseWriter, err error, hooks *Hooks) {
	// Even if the caller sends TypeProtoTwirp, we respond with TypeJSON on errors.
	w.Header().Set("Content-Type", TypeJSON)
	s := newTwirpStatus(err)
	bs, merr := json.Marshal(s)
	if merr != nil {
		hooks.onMarshalError(ctx, merr)
		w.WriteHeader(http.StatusInternalServerError)
		// codes don't need to be escaped in JSON, so this is okay
		const tmpl = `{"code": "%s", "msg": "error marshaling error with code %s"}`
		if _, nerr := fmt.Fprintf(w, tmpl, CodeInternal.twirp(), s.Code); nerr != nil {
			hooks.onNetworkError(ctx, nerr)
		}
		return
	}
	w.WriteHeader(CodeOf(err).http())
	_, err = w.Write(bs)
	if err != nil {
		hooks.onNetworkError(ctx, err)
	}
}

func writeErrorGRPC(ctx context.Context, w http.ResponseWriter, err error, hooks *Hooks) {
	if err == nil {
		w.Header().Set("Grpc-Status", strconv.Itoa(int(CodeOK)))
		w.Header().Set("Grpc-Message", "")
		w.Header().Set("Grpc-Status-Details-Bin", "")
		return
	}
	// gRPC errors are successes at the HTTP level and net/http automatically
	// sends a 200 if we don't set a status code. Leaving the HTTP status
	// implicit lets us use this function when we hit an error partway through
	// writing the body.
	s := statusFromError(err)
	code := strconv.Itoa(int(s.Code))
	// If we ever need to send more trailers, make sure to declare them in the headers
	// above.
	if bin, err := proto.Marshal(s); err != nil {
		w.Header().Set("Grpc-Status", strconv.Itoa(int(CodeInternal)))
		w.Header().Set("Grpc-Message", percentEncode("error marshaling protobuf status with code "+code))
		hooks.onMarshalError(ctx, err)
	} else {
		w.Header().Set("Grpc-Status", code)
		w.Header().Set("Grpc-Message", percentEncode(s.Message))
		w.Header().Set("Grpc-Status-Details-Bin", encodeBinaryHeader(bin))
	}
}

func statusFromError(err error) *statuspb.Status {
	s := &statuspb.Status{
		Code:    int32(CodeUnknown),
		Message: err.Error(),
	}
	if re, ok := AsError(err); ok {
		s.Code = int32(re.Code())
		s.Details = re.Details()
		if e := re.Unwrap(); e != nil {
			s.Message = e.Error() // don't repeat code
		}
	}
	return s
}

func newTwirpStatus(err error) *twirp.Status {
	gs := statusFromError(err)
	s := &twirp.Status{
		Code:    Code(gs.Code).twirp(),
		Message: gs.Message,
	}
	if te, ok := asTwirpError(err); ok {
		s.Code = te.TwirpCode()
	}
	return s
}
